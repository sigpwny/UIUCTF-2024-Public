Solution code can be found in `attack.sage`.

This challenge was an implementation of a [Merkle-Hellman Knapsack Cryptosystem](https://en.wikipedia.org/wiki/Merkle%E2%80%93Hellman_knapsack_cryptosystem).
The security of many cryptosystems relies on the hardness of some problem, such as Discrete Log or Integer Factorization.
This is no difference.
The Merkle-Hellman Knapsack relies on the hardness of the Subset-Sum problem where given a target value `T` a collection of values `{c1, ..., cn}`, find integers `b1, ..., bn` such that each `bi = 0 or 1` and `b1*c1 + ... + bn*cn = T`.
Setting `bi = 1` represents "choosing" `ci` from the knapsack `{c1, ..., cn}`.
We can use the `bi` as a bitstring and this is how we can encode messages using this system.
In general, this is a hard problem.
However, we also want a cryptosystem to be efficient.
Otherwise no one will use it to encrypt anything.
If we use an arbitrary set of values, then decryption will be impossible to do efficiently (unless someone shows `P = NP`).
Thus, we use a "super-increasing" knapsack where each `ci` satisfies `ci > c1 + ... c(i-1)`, i.e. each `bi` is greater than the sum of the previous small `bj` for `j < i`.
We then "disguise" this knapsack from appearing to be super increasing by multiplying each `ci` by a secret value `W` and setting `ai = ci * W % M` for a secret modulus `M`.
This seems to "scramble" the `ci` and form a new knapsack `ai`.
We further scramble the `ai` by randomly permuting them.
See this [Knapsack Survey](https://www-users.cse.umn.edu/~odlyzko/doc/arch/knapsack.survey.pdf) by A. M. Odlyzko for more details.
However, it turns out that this system is insecure even when properly implemented.

The attack is quite simple.
I will not write out all the details, as this paper [Lattice Reduction Attack on the Knapsack](https://www.cs.sjsu.edu/faculty/stamp/papers/topics/topic16/Knapsack.pdf) by Mark Stamp writes out the attack far better than I ever could.
Following this exactly will show you how to come up with the matrix for the lattice attack and why the shorter basis vectors generated by the `LLL` algorithm yield an answer to our problem.
Why would one want a shorter basis?
The basis of the matrix described in the Stamp paper is a set of vectors that are solutions to the knapsack problem.
However, we do not want arbitrary solutions.
We want special integer solutions which consist of just `0`s and `1`s.
These vectors are quite short, with respect to the Euclidian metric `||(v1, ..., vn)|| = sqrt(v1^2 + ... _ vn^2)`.
The `LLL` algorithm exactly finds basis vectors with such short lengths, if they exist.
Thus, it is the right algorithm to use to break the cryptosystem.

Special shout-out to `@Shorden` for leaking the flag on accident via an over zealous commit.
The flag is a reference to this occurrence:
`flag = uiuctf{i_g0t_sleepy_s0_I_13f7_th3_fl4g}`.
